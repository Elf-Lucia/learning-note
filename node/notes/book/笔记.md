



## 什么是JavaScript？

- 脚本语言
- 运行在浏览器中
- 一般用来做客户端页面的交互
- 运行在浏览器内核中的js引擎

## 浏览器中的JavaScript能做什么？不能做什么？

- 操作DOM(对DOM的增删改、注册事件)

- AJAX/跨域

- BOM(页面跳转、历史记录、console.log、alert)

- ECMASCRIPT

- 不可以进行文件操作（文件和文件夹的crud）

- 没办法操作系统

  

## 编程语言的能力取决于什么？

+ 语言本身只是提供定义变量、定义函数、流程控制、循环结构之类的操作
+ 取决于这个运行改语言的平台（环境）
+ 对于js来说，我们常说的JS实际就是es，大部分能力都是由浏览器的执行引擎决定的
+ BOM和DOM可以说是浏览器开放出来的接口
+ 比如，cordova中提供js调用摄像头，操作本地文件的API
+ JAVA既是语言也是平台
+ Java运行在Java虚拟机
+ **语言的能力一定取决于平台**


## JavaScript只可以运行在浏览器中吗？
+ 不是
+ 能运行在哪，取决于这个环境有没有特定的平台

## 什么是node？

+ Nodejs是javascript运行环境
+ node是JavaScript的工具库

## why JavaScript

+ 是node选择了JavaScript而不是JavaScript发展出来了一个node
+ JavaScript是目前开发行业中最火热的语言，会的人很多

## 安装node

+ 下载：https://nodejs.org/en/download
+ 解压到一个全英文的包
+ 编辑解压的setting.txt文件
+ 配置环境变量![1567235303315](C:\Users\17746\AppData\Roaming\Typora\typora-user-images\1567235303315.png)
- NVM_HOME = 当前nvm。exe所在的目录
- NVM_SYMLINK =NODE快捷方式所在的目录
- PATH += %NVM_HOME%;%NVM_SYMLINK% 
- 打开cmd通过set命令查看环境变量是否配置成功
- path当中配置的可以在任何目录下搜索

## windows中powershell的常用的命令行操作

切换当前目录（change directory） :cd

获取当前路径   ：pwd

创建目录   ：mkdir

删除文件   ：rm



## REPL环境

进入repl环境(类似于控制台)

+ node --use——strict：启用严格模式

## 全局对象

+ global

  类似于客户端JavaScript中的Window,node中没有window对象

+ process

  用于获取当前的node进程信息，一般用于获取环境变量之类的信息、

  + console



## 将图片转换为字符画的工具   http://graeve.com/

## node调试

+ nodejs文档中的debugger
+ 第三方提供的调试工具 
+ - npm install node-inspector -g
  - 
+ 开发工具的调试
+ + visual studo code
  + webstorm

## 回调函数

+ 如果函数需要回调参数，一定是在参数的最后出现
+ 错误优先的回调函数（第一个参数是错误的，第二个才是需要的参数）

function isEvenOrodd(number，callback){

if(typeof number ==='number'){}

else{

// throw new err（‘你输入的不是数字’）

}

}

## 什么是异步？

+ setTimeOut()
+ $.ajax()
+ 文件操作
+ node所有的会发生阻塞的事件都是异步的



## 什么是I/O

I/O:[INPUT/OUTPUT]从输入到输出之间的转化过程

## 进程和线程

- 什么是进程和线程？

  进行中的程序（运行中的exe),进程启动过后，默认会创建一个线程，线程用于执行代码，由于代码执行有的会耗费时间，所以一个进程会有多个线程

- 线程是不是越多越好？

  不是的，执行代码的时间取决于当前cpu忙不忙

- 多线程的问题

  多线程都是假的，因为只有一个CPU（单核的），线程之间共享数据，同步某个状态很麻烦，创建线程耗费资源，线程数量有限，cpu在不同线程之间转换，有个上下文转换，这个转换非常耗时，单线程比多线程还要快

## 事件驱动

+ fs

​          fs.stat(path,(err,stats)=>{})  查询文件状态

​          //有的话删除文件，fs.unlink(path,(err)=>{

​         //没有创建文件  fs.writefile(path,写进文件的内容,(err)=>{})

​         })

执行到函数时，会将函数放到事件队列当中，当成员执行完了会执行队列当中的函数，事件队列中有比较耗时的会放到资源池当中，事件队列继续执行

## 阻塞操作

执行函数需要花时间

## 模块化

模块与文件是一一对应关系，即加载一个模块，实际上就是加载对应的一个模块文件，每个模块的内部都是私有空间

文件模块——我们自己写的文件模块

核心模块——node自带的

第三方模块——第三方定义的

+ 模块化开发流程

+ 模块的定义：模块是一个封闭的所用域，不需要写自执行函数

+ __dirname  获取当前脚本所在的目录路径

+ 所有的文件路径都要是绝对路径   __dirname+文件路径

+ __filename 文件的绝对路径

+ module对象：模块对象     载入一个模块就是创建一个Module实例

+ ​                                           通过module.parent返回一个对象，来判断当前文件是否被别的文件加载，否则就是入口文件

  ​                                           module.loaded返回一个布尔值，表示模块是否加载完成

  ​                                           module.filename  模块定义的文件的绝对路径

  ​                                           module.children返回一个对象，来查找当前模块加载的所有的子文件

+ exports:表示模块对外输出的值，映射到module.exports的别名

+ exports.name=value;module.exports ={name:value}

## require

- require扩展名--require不仅仅可以载入js模块，也可以载入json对象（大部分用于读取配置）

- - require加载文件时可以省略扩展名             按js,json,node的格式去查找文件，载入module目录中package.json中main指向的文件，载入目录module中的index.js文件

- 加载机制

- ./ :按照相对路径从当前文件所在文件夹开始查找文件，加载文件，不然认为加载的是核心模块（模块名重复，系统模块的优先级最高）

  ../   :按照相对路径，从上层目录中查找文件

## 核心模块

- https://nodejs.org/api
- 意义： 只是在服务器端运行JavaScript代码，没有任何意义，需要实现功能（读写文件，访问网络），node本身提供了一系列功能模块
- 常用的内置模块清单
- - path：处理文件路径
  - fs: 操作（CRUD）文件系统
  - child_process:新建子进程
  - util: 提供一系列实用小工具
  - http:提供http服务器功能
  - url:用于解析URL
  - querystring:解析url中的查询字符串
  - crypto:提供加密解密功能

## 

## NPM包管理工具   http://www.npmjs.com

+ 什么是包？
+ - 提供了一系列的内置模块，但是不满足开发的需求，就有了包的概念，将一些功能封装好以便复用
+ 包的情况：先在系统的模块中找，再到项目的node_modules目录中找

## 路径操作模块(path)

+ 获取不同操作系统中默认的路径分隔符

  -  path.delimiter

+ 获取文件路径的目录名称 

  + dirname

+ 获取路径中的扩展名，包含.

+ - extname

+ 将路径字符串转为一个对象（包含文件目录，文件名，扩展名）

  - ```js
    path.parse('/home/user/dir/file.txt');
    // Returns:
    // { root: '/',
    //   dir: '/home/user/dir',
    //   base: 'file.txt',
    //   ext: '.txt',
    //   name: 'file' }
    ```

+ 路径对象转换为字符串

  - ```js
    path.format({
      root: '/ignored',
      dir: '/home/user/dir',
      base: 'file.txt'
    });
    // Returns: '/home/user/dir/file.txt'
    ```

+ 判断路径是不是绝对路径   path.isAbsolute(temp)

+ 拼合路径

  - ```js
    path.join('/foo', 'bar', 'baz/asdf', 'quux', '..');
    // Returns: '/foo/bar/baz/asdf'
    ```

+ 常规化一个路径（根据当前操作系统将路径改正确）

  - ```js
    path.normalize('/foo/bar//baz/asdf/quux/..');
    // Returns: '/foo/bar/baz/asdf'
    ```

+ ```js
  path.basename('C:\\temp\\myfile.html');// 获取文件名
  ```

+ 获取to相对于from的相对路径（path.relative(from, to)）

  - ```js
    path.relative('/data/orandea/test/aaa', '/data/orandea/impl/bbb');
    // Returns: '../../impl/bbb'
    ```

+ 与join不同，不仅仅是单纯的拼接

  - ```js
    path.resolve('/foo/bar', './baz');
    // Returns: '/foo/bar/baz'
    ```

+ 获取当前操作系统中默认用的路径成员分隔符(path.sep)， windows:\     linux:/
+ 允许在任意操作系统上使用windows的方式操作路径  path.win32
+ 允许在任意操作系统上使用lunix的方式操作路径   path.posix



## 文件系统操作（fs）

+ fs对文件的操作分为两种情况   同步（async）和异步，默认的是异步
  - 同步和异步的区别：
    - 异步：fs.readfile，需要传回调，通过error获取错误
    - 同步：fs.readfileasync，因为等文件读完才会进行，会产生阻塞，不需要传回调，通过try，catch获取错误
+ Buffer：
  - 读文件时没有指定编码格式，默认读取的是一个Buffer(缓冲区)
  - 缓冲区是内存中操作数据的容器，只是数据容器而已
  - 通过缓冲区可以很方便的操作二进制数据
  - 大文件操作时必须有缓冲区
  - readfile的方式确实是使用buffer,但是也是一次性读取
  - 将图片转换为base64位编码   data.tostring('base64')
  - 文件解码的问题：
    - tostring,默认是utf8
    - 第三方包 iconv-lite
+ 文件流：我们的代码要读取buffer中的数据，先从要读取的文件中读取buffer大小的数据传到buffer中，传给我们，来一个传一个
+ readline，读取大文本文件， 一行一行读取文件
+ 文件写入
  - 异步文件写入  fs.writeFile
  - 同步文件写入fs.writeFileSync
  - 流式文件写入  fs.createWriteStream(path[,option])
  - 异步追加  fs.appendFile
  - 同步追加    fs.appendFileSync
+ 其他文件操作
  - rename(op1,op2)  移动目录
  - unlink  删除文件
+ 递归
+ 先写一层的情况
+ 抽象递归参数
+ 找到突破点（避免死循环）
+ 自己调自己，某种情况不调用









































